;
; Simple flashing cursor with arrow keys
;
*LASTKEY : $0d  ; last key press
*SCRN_LO : $a0  ; screen RAM low address
*SCRN_HI : $b4  ; screen RAM high address

*CRSR_ROW : $ca ; cursor y position
*CRSR_COL : $cb ; cursor x position
*BLINK_ON : $cc ; cursor blink enabled
*BLINK_CT : $cd ; countdown timer
*CRSRCHAR : $ce ; character under cursor
*BLINK_ST : $cf ; cursor blink state

*PLOT_LO : $f0
*PLOT_HI : $f1
*READ_LO : $f2
*READ_HI : $f3

; --------------------------------------
; Screen RAM low bytes
; --------------------------------------
> 00a0 00 32 64 96 c8 fa 2c 5e
> 00a8 90 c2 f4 26 58 8a bc ee
> 00b0 20 52 84 b6

; --------------------------------------
; Screen RAM high bytes
; --------------------------------------
> 00b4 10 10 10 10 10 10 11 11
> 00bc 11 11 11 12 12 12 12 12
> 00c4 13 13 13 13

> fffc 00 c0       ; reset vector
> 00cc 01          ; blink on
> 00cd 14          ; cursor timer

; --------------------------------------
; set IRQ vector
; --------------------------------------
. c000 SEI
. c001 LDA #$00
. c003 STA $fffe ; vector low byte
. c006 LDA #$e0
. c008 STA $ffff ; vector high byte
. c00b CLI

; --------------------------------------
; main loop
; --------------------------------------
. c00c LDA *LASTKEY  ; read key
. c00e BEQ $c00c     ; zero? no key pressed
. c010 AND #$60      ; 0110 0000 mask; destroys AC
. c012 BNE $c017     ; printable?
. c014 JMP $c100     ; jump if not printable
; --------------------------------------
; handle printable character
; --------------------------------------
. c017 LDA #$00
. c019 STA *BLINK_ON ; disable cursor blink
. c01b LDA *LASTKEY  ; place new character at cursor
. c01d JSR $d000     ; plot char (AC) at cursor
. c020 JSR $d100     ; cursor right
; --------------------------------------
; entry point for end of main loop
; --------------------------------------
. c023 JSR $d011     ; update character under cursor
. c026 LDA *CRSRCHAR ; get char at new cursor position
. c028 LDX *BLINK_ST ; get blink state
. c02a BEQ $c02e     ; blink == 0, skip toggle
. c02c EOR #$80      ; toggle inverse video at cursor
. c02e JSR $d000     ; plot char (AC) at new cursor 
. c031 LDA #$00      ; clear last key register
. c033 STA *LASTKEY
. c035 LDA #$01      ; enable cursor blink
. c037 STA *BLINK_ON
. c039 JMP $c00c     ; loop back
; --------------------------------------
; handle non-printable character
; this is really inefficient...
; ...and not DRY :)
; --------------------------------------
. c100 LDA #$00
. c102 STA *BLINK_ON ; disable cursor blink
. c104 LDA *LASTKEY
;
; ARROW_RIGHT
;
. c106 CMP #$1d      ; ARROW_RIGHT
. c108 BNE $c115     ; check another match
. c10a LDA *CRSRCHAR ; reprint char under old cursor
. c10c JSR $d000
. c10f JSR $d100     ; cursor right subroutine
. c112 JMP $c023     ; end of main loop
;
; ARROW_DOWN
;
. c115 CMP #$1e      ; ARROW_DOWN
. c117 BNE $c124     ; check another match
. c119 LDA *CRSRCHAR ; reprint char under old cursor 
. c11b JSR $d000
. c11e JSR $d10c     ; cursor down subroutine
. c121 JMP $c023     ; end of main loop
;
; ARROW_LEFT
;
. c124 CMP #$1f      ; ARROW_LEFT
. c126 BNE $c133     ; check another match
. c128 LDA *CRSRCHAR ; reprint char under old cursor
. c12a JSR $d000     ;
. c12d JSR $d200     ; cursor left subroutine
. c130 JMP $c023     ; end of main loop
;
; ARROW_UP
;
. c133 CMP #$1c      ; ARROW_UP
. c135 BNE $c142     ; check another match
. c137 LDA *CRSRCHAR ; reprint char under old cursor
. c139 JSR $d000     ;
. c13c JSR $d300     ; cursor up subroutine
. c13f JMP $c023     ; end of main loop
;
; ENTER
;
. c142 CMP #$0d      ; ENTER
. c144 BNE $c151     ; check another match
. c146 LDA *CRSRCHAR ; reprint char under old cursor
. c148 JSR $d000     ;
. c14b JSR $d320     ; carriage return subroutine
. c14e JMP $c023     ; end of main loop
;
; DELETE
;
. c151 CMP #$08      ; DELETE
. c153 BNE $c151     ; check another match
. c155 LDA *CRSRCHAR ; reprint char under old cursor
. c157 JSR $d000     ;
. c15a JSR $d340     ; delete subroutine
. c15d JMP $c023     ; end of main loop
. c160 JMP $c00c
. c163 JMP $c00c

; --------------------------------------
; Plot one character at cursor position:
; AC: ASCII value; XR, YR: row, column
; (yes, reverse Cartesian for speed)
; JSR $d000 to plot. AC preserved.
; --------------------------------------
. d000 PHA
. d001 LDX *CRSR_ROW
. d003 LDY *CRSR_COL
. d005 LDA *SCRN_LO,x
. d007 STA *PLOT_LO
. d009 LDA *SCRN_HI,x
. d00b STA *PLOT_HI
. d00d PLA 
. d00e STA (*PLOT_LO),y
. d010 RTS

; --------------------------------------
; Update character at cursor position;
; store in *CRSRCHAR
; JSR $d011 to update. AC not preserved.
; --------------------------------------
. d011 LDX *CRSR_ROW
. d013 LDY *CRSR_COL
. d015 LDA *SCRN_LO,x
. d017 STA *PLOT_LO
. d019 LDA *SCRN_HI,x
. d01b STA *PLOT_HI
. d01d LDA (*PLOT_LO),y
. d01f STA *CRSRCHAR
. d021 RTS

; --------------------------------------
; move cursor right
; --------------------------------------
. d100 INC *CRSR_COL ; advance cursor column (right)
. d102 LDA #$32      ; #$32 == past right edge
. d104 CMP *CRSR_COL ; did we pass right edge?
. d106 BNE $d119     ; skip if in bounds
. d108 LDA #$00      ; reset cursor to left
. d10a STA *CRSR_COL
; --------------------------------------
; entry point for cursor down
; --------------------------------------
. d10c INC *CRSR_ROW ; current cursor row
. d10e LDA #$14      ; #$14 == past bottom edge
. d110 CMP *CRSR_ROW ; did we pass bottom?
. d112 BNE $d119     ; skip if in bounds
. d114 DEC *CRSR_ROW ; bring cursor back to bottom row
. d116 JSR $d400     ; scroll screen
. d119 RTS

; --------------------------------------
; move cursor left
; --------------------------------------
. d200 DEC *CRSR_COL
. d202 BPL $d20e     ; skip if in bounds
. d204 LDA *CRSR_ROW ; check for top row
. d206 BEQ $d20f     ; skip if top (== 0)
. d208 LDA #$31      ; set cursor to right
. d20a STA *CRSR_COL
. d20c DEC *CRSR_ROW
. d20e RTS
. d20f INC *CRSR_COL ; column is $ff, make $00
. d211 RTS

; --------------------------------------
; move cursor up
; --------------------------------------
. d300 DEC *CRSR_ROW
. d302 BPL $d306     ; skip if in bounds
. d304 INC *CRSR_ROW ; check for top row
. d306 RTS

; --------------------------------------
; carriage return
; --------------------------------------
. d320 LDA #$00      ; set column to zero
. d322 STA *CRSR_COL
. d324 JSR $d10c     ; call cursor down
. d327 RTS

; --------------------------------------
; delete/backspace
; --------------------------------------
. d340 JSR $d200        ; cursor left subroutine
. d343 LDX *CRSR_ROW    ; where is my cursor?
. d345 LDY *CRSR_COL
. d347 INY              ; go one past
. d348 CPY #$32         ; off-screen?
. d34a BEQ $d35d        ; yes? finish routine
. d34c LDA *SCRN_LO,x   ; find RAM address of position
. d34e STA *READ_LO
. d350 LDA *SCRN_HI,x
. d352 STA *READ_HI
. d354 LDA (*READ_LO),y ; read character at position
. d356 DEY
. d357 STA (*READ_LO),y
. d359 INY
. d35a JMP $d347
. d35d DEY              ; back to last column
. d35e LDA #$20         ; ASCII space
. d360 STA (*READ_LO),y
. d362 LDY *CRSR_COL
. d364 CPY #$31         ; last column?
. d366 BNE $d36b
. d368 JSR $d000        ; plot space under cursor
. d36b STA *CRSRCHAR
. d36d RTS

; --------------------------------------
; scroll screen up one line
; --------------------------------------
. d400 LDX #$01         ; set XR to row 1
. d402 LDY #$31         ; set YR to col 49
. d404 LDA *SCRN_LO,x   ; find RAM address of position
. d406 STA *READ_LO
. d408 LDA *SCRN_HI,x
. d40a STA *READ_HI
. d40c LDA (*READ_LO),y ; read character at position
. d40e PHA              ; save character to stack
. d40f DEX              ; previous row
. d410 LDA *SCRN_LO,x   ; find RAM address of new position
. d412 STA *PLOT_LO
. d414 LDA *SCRN_HI,x
. d416 STA *PLOT_HI
. d418 PLA              ; get character back from stack
. d419 STA (*PLOT_LO),y ; plot character
. d41b INX              ; back to current row
. d41c DEY              ; left one column
. d41d BPL $d404        ; loop until negative
. d41f INX              ; next row
. d420 TXA
. d421 CMP #$14         ; is row past bottom?
. d423 BNE $d402        ; still rows, keep looping
. d425 LDY #$31         ; loop to clear last line
. d427 LDA #$00
. d429 STA $13b6,y
. d42c DEY
. d42d BPL $d429
. d42f RTS

; --------------------------------------
; interrupt routine - flash cursor
; preserves AC, XR, and YR
; --------------------------------------
. e000 PHA              ; stash registers
. e001 TXA
. e002 PHA
. e003 TYA
. e004 PHA
. e005 LDA *BLINK_ON    ; 0 == blink off
. e007 BEQ $e029        ; exit if blink off
. e009 DEC *BLINK_CT    ; decrease countdown
. e00b BNE $e029        ; exit if not zero
. e00d LDA #$14         ; reload countdown
. e00f STA *BLINK_CT
. e011 LDA *BLINK_ST    ; toggle blink state
. e013 EOR #$01
. e015 STA *BLINK_ST

. e017 LDX *CRSR_ROW    ; get row base screen address
. e019 LDA *SCRN_LO,x   ; into zero page
. e01b STA *PLOT_LO
. e01d LDA *SCRN_HI,x
. e01f STA *PLOT_HI

. e021 LDY *CRSR_COL
. e023 LDA (*PLOT_LO),y ; get cursor RAM address
. e025 EOR #$80         ; toggle RVS
. e027 STA (*PLOT_LO),y ; write new char to screen

. e029 PLA              ; restore registers
. e02a TAY
. e02b PLA
. e02c TAX
. e02d PLA
. e02e RTI
