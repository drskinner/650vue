; ------------------------------------------------------------------------------
; 650Vue Kernal routines.
; "Kernal" is Commodore's misspelling of kernel.
;
; All the useful "ROM" routines that serve as the building blocks of larger
; programs. Keyboard and screen I/O, various string and math routines.
;
; Copyright Â© 2020 Dr. Myles L. Skinner - All Rights Reserved.
; ------------------------------------------------------------------------------

@SetReset $c000

:zp_last_key   = $0e    ; last key press
:zp_random     = $0f    ; random number

:screen_row_lo = $a0    ; screen RAM low address table
:screen_row_hi = $b4    ; screen RAM high address table

:last_row_base = $13b6  ; base address of last screen row

; ------------------------------------------------------------------------------
; Screen RAM low bytes
; ------------------------------------------------------------------------------
> 00a0 00 32 64 96 c8 fa 2c 5e
> 00a8 90 c2 f4 26 58 8a bc ee
> 00b0 20 52 84 b6

; ------------------------------------------------------------------------------
; Screen RAM high bytes
; ------------------------------------------------------------------------------
> 00b4 10 10 10 10 10 10 11 11
> 00bc 11 11 11 12 12 12 12 12
> 00c4 13 13 13 13

:cursor_row     = $ca ; cursor y position
:cursor_col     = $cb ; cursor x position
:blink_enabled  = $cc ; cursor blink enabled
:blink_counter  = $cd ; countdown timer
:cursor_char    = $ce ; character under cursor
:blink_state    = $cf ; cursor blink state

> 00ca 00 00          ; cursor at "home" position
> 00cc 00             ; blink off
> 00cd 14             ; cursor timer

:input_prompt   = $e0  ; character for prompt (`?`)
:input_length   = $e1  ; max chars for input
> 00e0 3f 08
:input_buffer   = $0200

:plot_row       = $f0
:read_row       = $f2
:string_ptr     = $f4

:xr_temp        = $fe
:yr_temp        = $ff

; set ASCII character values for control characters
:arrow_down    = #$1e
:arrow_left    = #$1f
:arrow_right   = #$1d
:arrow_up      = #$1c
:ascii_null    = #$00
:ascii_delete  = #$08
:ascii_enter   = #$0d

; set ASCII values for punctuation marks
:ascii_apostrophe = #$27
:ascii_colon      = #$3a
:ascii_dollar     = #$24
:ascii_dot        = #$2e
:ascii_hash       = #$23
:ascii_space      = #$20

* = $e000
; ------------------------------------------------------------------------------
; Move cursor up. This move is very simple: move the cursor up one row, but
; not beyond the top edge.
; ------------------------------------------------------------------------------
moveCursorUp        dec :cursor_row
                    bpl exitCursorUp    ; skip if in bounds
                    inc :cursor_row     ; check for top row
exitCursorUp        rts

; ------------------------------------------------------------------------------
; Move cursor right. If we go off the right edge, then we're on the next line.
; Beacuse we have advanced one line, cursor right dovetails with cursor down. 
; ------------------------------------------------------------------------------
moveCursorRight     inc :cursor_col     ; advance cursor column (right)
                    lda #$32            ; #$32 == past right edge
                    cmp :cursor_col     ; did we pass right edge?
                    bne exitCursorRight ; skip if in bounds
                    lda #$00            ; reset cursor to left
                    sta :cursor_col
; ------------------------------------------------------------------------------
; entry point for cursor down
; ------------------------------------------------------------------------------
moveCursorDown      inc :cursor_row     ; current cursor row
                    lda #$14            ; #$14 == past bottom edge
                    cmp :cursor_row     ; did we pass bottom?
                    bne exitCursorRight ; skip if in bounds
                    dec :cursor_row     ; bring cursor back to bottom row
                    jmp scrollScreen
exitCursorRight     rts

; ------------------------------------------------------------------------------
; Move cursor left. If we go off the left edge, then we're on the previous line.
; Can't go any higher than the top line; in this situation, the cursor column
; has rolled over to $ff, so we need to correct its position.
; ------------------------------------------------------------------------------
moveCursorLeft      dec :cursor_col
                    bpl exitCursorLeft0 ; skip if in bounds
                    lda :cursor_row     ; check for top row
                    beq exitCursorLeft1 ; skip if top (== 0)
                    lda #$31            ; set cursor to right
                    sta :cursor_col
                    dec :cursor_row
exitCursorLeft0     rts
exitCursorLeft1     inc :cursor_col     ; column is $ff, make $00
                    rts

; ------------------------------------------------------------------------------
; Execute backspace. The cursor moves left, erasing where it lands.
; ------------------------------------------------------------------------------
doBackspace         lda #$00
                    jsr plotCharAtCursor
                    jsr moveCursorLeft    ; cursor left subroutine
                    jsr plotCharAtCursor
                    rts

; ------------------------------------------------------------------------------
; Execute carriage return. It's as simple as moving the cursor to column 0,
; and moving the cursor to the next line, which will trigger a scroll at the
; bottom of the screen.
; ------------------------------------------------------------------------------
doCarriageReturn    lda #$00            ; set column to zero
                    sta :cursor_col
                    jmp moveCursorDown  ; call cursor down
                    rts

; ------------------------------------------------------------------------------
; Execute delete. The cursor moves left, pulling everything up to the
; end of the line along with it. A delete from column 0 will erase the last
; character on the previous line.
; ------------------------------------------------------------------------------
doDelete            jsr moveCursorLeft    ; cursor left subroutine
                    ldx :cursor_row       ; where is my cursor?
                    ldy :cursor_col
pullNextChar        iny                   ; go one past
                    cpy #$32              ; off-screen?
                    beq endDelete         ; yes? finish routine
                    lda :screen_row_lo,x  ; find RAM address of position
                    sta :read_row
                    lda :screen_row_hi,x
                    sta :read_row+1
                    lda (:read_row),y ; read character at position
                    dey
                    sta (:read_row),y
                    iny
                    jmp pullNextChar
endDelete           dey                   ; back to last column
                    lda :ascii_space
                    sta (:read_row),y
                    ldy :cursor_col
                    cpy #$31              ; last column?
                    bne exitDelete
                    jsr plotCharAtCursor  ; plot space under cursor
exitDelete          sta :cursor_char
                    rts

; ------------------------------------------------------------------------------
; Scroll screen up one line. Copies one row at a time and fills the last line
; with blanks.
; ------------------------------------------------------------------------------
scrollScreen    ldx #$01              ; set XR to row 1
startRowScroll  ldy #$31              ; set YR to col 49
loopScrollChar  lda :screen_row_lo,x  ; find RAM address of position
                sta :read_row
                lda :screen_row_hi,x
                sta :read_row+1
                lda (:read_row),y ; read character at position
                pha                   ; save character to stack
                dex                   ; previous row
                lda :screen_row_lo,x  ; find RAM address of new position
                sta :plot_row
                lda :screen_row_hi,x
                sta :plot_row+1
                pla                   ; get character back from stack
                sta (:plot_row),y ; plot character
                inx                   ; back to current row
                dey                   ; left one column
                bpl loopScrollChar    ; loop until negative
                inx                   ; next row
                txa
                cmp #$14              ; is row past bottom?
                bne startRowScroll    ; still rows, keep looping
                ldy #$31              ; loop to clear last line
                lda :ascii_space
loopLastLine    sta :last_row_base,y
                dey
                bpl loopLastLine
                rts

; ------------------------------------------------------------------------------
; Plot one character at cursor position:
; AC: ASCII value; XR, YR: row, column
; (yes, reverse Cartesian for speed)
; AC preserved.
; ------------------------------------------------------------------------------
plotCharAtCursor    pha
                    ldx :cursor_row
                    ldy :cursor_col
                    lda :screen_row_lo,x
                    sta :plot_row
                    lda :screen_row_hi,x
                    sta :plot_row+1
                    pla 
                    sta (:plot_row),y
                    rts

; ------------------------------------------------------------------------------
; Print one character at cursor position:
; AC: ASCII value; XR, YR: row, column
; Similar to plotCharAtCursor but finishes with a cursor right.
; AC preserved.
; ------------------------------------------------------------------------------
printCharAtCursor   pha
                    ldx :cursor_row
                    ldy :cursor_col
                    lda :screen_row_lo,x
                    sta :plot_row
                    lda :screen_row_hi,x
                    sta :plot_row+1
                    pla 
                    sta (:plot_row),y
                    jmp moveCursorRight
                    rts

; ------------------------------------------------------------------------------
; print string at cursor location
; :string_ptr - address of string
; set :cursor_row and :cursor_col before calling
; ------------------------------------------------------------------------------
printString         ldy #$00
loopPrintString     lda (:string_ptr),y
                    beq exitPrintString
                    sty :yr_temp
                    jsr printCharAtCursor
                    ldy :yr_temp
                    iny
                    jmp loopPrintString
exitPrintString     rts

; ------------------------------------------------------------------------------
; print string at cursor location
; :string_ptr - address of string
; set :cursor_row and :cursor_col before calling
; ------------------------------------------------------------------------------
printStringRVS      ldy #$00
loopPrintStringRVS  lda (:string_ptr),y
                    beq exitPrintStringRVS
                    sty :yr_temp
                    ora #$80                ; set high bit (RVS)
                    jsr printCharAtCursor
                    ldy :yr_temp
                    iny
                    jmp loopPrintStringRVS
exitPrintStringRVS  rts

; ------------------------------------------------------------------------------
; print string at cursor location, followed by carriage return
; :string_ptr - address of string
; set :cursor_row and :cursor_col before calling
; ------------------------------------------------------------------------------
printStringWithCR   ldy #$00
loopPrintStringCR   lda (:string_ptr),y
                    beq exitPrintStringCR
                    sty :yr_temp
                    jsr plotCharAtCursor
                    jsr moveCursorRight
                    ldy :yr_temp
                    iny
                    jmp loopPrintStringCR
exitPrintStringCR   jmp doCarriageReturn
                    rts

; ------------------------------------------------------------------------------
; Update character at cursor position (what appears "under" the cursor);
; store in :cursor_char
; AC not preserved.
; ------------------------------------------------------------------------------
setCharUnderCursor  ldx :cursor_row
                    ldy :cursor_col
                    lda :screen_row_lo,x
                    sta :plot_row
                    lda :screen_row_hi,x
                    sta :plot_row+1
                    lda (:plot_row),y
                    sta :cursor_char
                    rts

; ------------------------------------------------------------------------------
; Clear screen; fills screen with nulls
; ------------------------------------------------------------------------------
clearScreen         lda :ascii_null
                    ldx #$fa
loopClearScreen     sta $0fff,x
                    sta $10f9,x
                    sta $11f3,x
                    sta $12ed,x
                    dex
                    bne loopClearScreen
                    rts

; ------------------------------------------------------------------------------
; Clear screen; fills screen with nulls
; ------------------------------------------------------------------------------
clearAndHomeScreen  lda :ascii_null
                    ldx #$fa
loopClearScreen     sta $0fff,x
                    sta $10f9,x
                    sta $11f3,x
                    sta $12ed,x
                    dex
                    bne loopClearScreen
                    sta :cursor_row
                    sta :cursor_col
                    rts

; ------------------------------------------------------------------------------
; input string from keyboard
; :string_ptr   - address of string to write
; :input_prompt - character for prompt
; :input_length - max characters
; set :cursor_row and :cursor_col before calling
; ------------------------------------------------------------------------------
inputWithPrompt     lda :input_prompt
                    jsr printCharAtCursor
                    lda :ascii_space
                    jsr printCharAtCursor
doInput             lda #$01
                    sta :blink_enabled
                    ldx #$00
inputReadKeyboard   lda :zp_last_key
                    beq inputReadKeyboard

testDelete          cmp :ascii_delete
                    bne testEnter           ; check another match
                    cpx #$00
                    beq inputClearLastKey   ; don't backspace beyond 0
                    stx :xr_temp
                    jsr doBackspace
                    ldx :xr_temp
                    dex
                    sta :input_buffer,x     ; put 0 in input buffer at cursor
                    jmp inputClearLastKey

testEnter           cpx #0                  ; string length is 0
                    beq testPrintable       ; ignore enter on empty string
                    cmp :ascii_enter
                    bne testPrintable
                    lda :ascii_space
                    jsr plotCharAtCursor
                    jmp moveBufferToString

testPrintable       and #$60                ; 0110 0000 mask; destroys AC
                    bne printableChar       ; printable?
                    jmp inputClearLastKey   ; jump if not printable
printableChar       cpx :input_length
                    beq inputClearLastKey
                    stx :xr_temp
                    lda :zp_last_key
                    sta :input_buffer,x     ; transfer character to buffer
                    jsr printCharAtCursor
                    ldx :xr_temp
                    inx

inputClearLastKey   lda #$00
                    sta :zp_last_key
                    jmp inputReadKeyboard

moveBufferToString  ldy #$00
loopMoveBuffer      lda :input_buffer,y
                    beq terminateString     ; end of string
                    sta (:string_ptr),y     ; move buffer byte to string
                    lda #$00
                    sta :input_buffer,y     ; clear buffer byte
                    iny
                    jmp loopMoveBuffer
terminateString     sta (:string_ptr),y

exitInput           sta :zp_last_key        ; clear last key (AC is already zero)
                    sta :blink_enabled      ; disable cursor blink
                    rts

; ------------------------------------------------------------------------------
; Generate a random number.
; :random_word+1 will contain a number in the range [0..:random_range]
; ------------------------------------------------------------------------------
getRandomNumber       lda #0
                      sta :random_word
                      sta :random_word+1
                      ldx :random_range
                      ldy :zp_random
randomLoop            clc
                      tya
                      adc :random_word
                      sta :random_word
                      bcc nextRandomLoop
                      inc :random_word+1
nextRandomLoop        dex
                      bne randomLoop
                      rts
