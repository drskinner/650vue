; ------------------------------------------------------------------------------
; Routines to collect string input and print strings on screen.
; 650Vue demo by Dr. Myles L. Skinner.
;
; Copyright Â© 2020 Dr. Myles L. Skinner - All Rights Reserved.
; ------------------------------------------------------------------------------

> fffc 00 c0 ; RESET vector



> 00ca 00 00 ; cursor at "home" position
> 00cc 00 ; blink on
> 00cd 14 ; cursor timer

> 00e0 3f 08




; ------------------------------------------------------------------------------
; Screen RAM low bytes
; ------------------------------------------------------------------------------
> 00a0 00 32 64 96 c8 fa 2c 5e
> 00a8 90 c2 f4 26 58 8a bc ee
> 00b0 20 52 84 b6

; ------------------------------------------------------------------------------
; Screen RAM high bytes
; ------------------------------------------------------------------------------
> 00b4 10 10 10 10 10 10 11 11
> 00bc 11 11 11 12 12 12 12 12
> 00c4 13 13 13 13

> 2000 57 68 61 74 20 69 73 20
> 2008 79 6F 75 72 20 6E 61 6D
> 2010 65 20 28 6D 61 78 2E 20
> 2018 38 20 63 68 61 72 61 63
> 2020 74 65 72 73 29 00
> 2026 50 72 65 73 73 20 61 6E
> 202e 79 20 6B 65 79 20 74 6F
> 2036 20 65 78 69 74 2E 00
> 203d 44 6F 6E 65 2E 00
> 2043 48 65 6C 6C 6F 2C 20 00
> 204b 2C 20 77 65 6C 63 6F 6D
> 2053 65 20 74 6F 20 6D 79 20
> 205b 69 6E 70 75 74 20 64 65
> 2063 6D 6F 2E 00
> 2067 00 00 00 00 00 00 00 00
> 206f 00
> 2070 45 4E 44 20 4F 46 20 53
> 2078 54 52 49 4E 47 53
; the `END OF STRINGS` does nothing but if you look at memory from $2000,
; you can see how the strings and reserved bytes are laid out in memory.

;
; Cursor Blink IRQ routine
; 650Vue by Dr. Myles Skinner.
;
; Relocatable - specify address before #INCLUDE

; ------------------------------------------------------------------------------
; interrupt routine - flash cursor
; preserves AC, XR, and YR
; ------------------------------------------------------------------------------
. e000 pha
. e001 txa
. e002 pha
. e003 tya
. e004 pha

. e005 lda $cc
. e007 beq $e029
. e009 dec $cd
. e00b bne $e029
. e00d lda #$14
. e00f sta $cd
. e011 lda $cf
. e013 eor #$01
. e015 sta $cf
. e017 ldx $ca
. e019 lda $a0,x
. e01b sta $f0
. e01d lda $b4,x
. e01f sta $f1
. e021 ldy $cb
. e023 lda ($f0),y
. e025 eor #$80
. e027 sta ($f0),y

. e029 pla
. e02a tay
. e02b pla
. e02c tax
. e02d pla
. e02e rti

; ------------------------------------------------------------------------------
; set IRQ vector to $e000
; ------------------------------------------------------------------------------
. c000 sei
. c001 lda #$00
. c003 sta $fffe
. c006 lda #$e0
. c008 sta $ffff
. c00b cli

. c00c lda #$00
. c00e sta $ca
. c010 sta $cb
. c012 jsr $c136

. c015 lda #$00
. c017 sta $f4
. c019 lda #$20
. c01b sta $f5
. c01d jsr $c10c

. c020 lda #$67
. c022 sta $f4
. c024 lda #$20
. c026 sta $f5
. c028 jsr $c14a
. c02b jsr $c0a3
. c02e jsr $c0a3

. c031 lda #$43
. c033 sta $f4
. c035 lda #$20
. c037 sta $f5
. c039 jsr $c10c
. c03c lda #$67
. c03e sta $f4
. c040 lda #$20
. c042 sta $f5
. c044 jsr $c10c
. c047 lda #$4b
. c049 sta $f4
. c04b lda #$20
. c04d sta $f5
. c04f jsr $c11e
;            jsr $c0a3

. c052 lda #$26
. c054 sta $f4
. c056 lda #$20
. c058 sta $f5
. c05a jsr $c10c
. c05d jsr $c0a3
. c060 jsr $c0a3
. c063 lda $0e
. c065 beq $c063
. c067 lda #$3d
. c069 sta $f4
. c06b lda #$20
. c06d sta $f5
. c06f jsr $c10c
. c072 lda #$00
. c074 sta $0e
. c076 brk

; ------------------------------------------------------------------------------
; Move cursor right. If we go off the right edge, then we're on the next line.
; Beacuse we have advanced one line, cursor right dovetails with cursor down.
; ------------------------------------------------------------------------------
. c077 inc $cb
. c079 lda #$32
. c07b cmp $cb
. c07d bne $c090
. c07f lda #$00
. c081 sta $cb
; ------------------------------------------------------------------------------
; entry point for cursor down
; ------------------------------------------------------------------------------
. c083 inc $ca
. c085 lda #$14
. c087 cmp $ca
. c089 bne $c090
. c08b dec $ca
. c08d jsr $c0b7
. c090 rts

; ------------------------------------------------------------------------------
; Move cursor left. If we go off the left edge, then we're on the previous line.
; Can't go any higher than the top line; in this situation, the cursor column
; has rolled over to $ff, so we need to correct its position.
; ------------------------------------------------------------------------------
. c091 dec $cb
. c093 bpl $c09f
. c095 lda $ca
. c097 beq $c0a0
. c099 lda #$31
. c09b sta $cb
. c09d dec $ca
. c09f rts
. c0a0 inc $cb
. c0a2 rts

; ------------------------------------------------------------------------------
; Execute carriage return. It's as simple as moving the cursor to column 0,
; and moving the cursor to the next line, which will trigger a scroll at the
; bottom of the screen.
; ------------------------------------------------------------------------------
. c0a3 lda #$00
. c0a5 sta $cb
. c0a7 jsr $c083
. c0aa rts

; ------------------------------------------------------------------------------
; Execute backspace. The cursor moves left, erasing where it lands.
; ------------------------------------------------------------------------------
. c0ab lda #$00
. c0ad jsr $c0e7
. c0b0 jsr $c091
. c0b3 jsr $c0e7
. c0b6 rts

; ------------------------------------------------------------------------------
; Scroll screen up one line. Copies one row at a time and fills the last line
; with blanks.
; ------------------------------------------------------------------------------
. c0b7 ldx #$01
. c0b9 ldy #$31
. c0bb lda $a0,x
. c0bd sta $f2
. c0bf lda $b4,x
. c0c1 sta $f3
. c0c3 lda ($f2),y
. c0c5 pha
. c0c6 dex
. c0c7 lda $a0,x
. c0c9 sta $f0
. c0cb lda $b4,x
. c0cd sta $f1
. c0cf pla
. c0d0 sta ($f0),y
. c0d2 inx
. c0d3 dey
. c0d4 bpl $c0bb
. c0d6 inx
. c0d7 txa
. c0d8 cmp #$14
. c0da bne $c0b9
. c0dc ldy #$31
. c0de lda $20
. c0e0 sta $13b6,y
. c0e3 dey
. c0e4 bpl $c0e0
. c0e6 rts

; ------------------------------------------------------------------------------
; Plot one character at cursor position:
; AC: ASCII value; XR, YR: row, column
; (yes, reverse Cartesian for speed)
; AC preserved.
; ------------------------------------------------------------------------------
. c0e7 pha
. c0e8 ldx $ca
. c0ea ldy $cb
. c0ec lda $a0,x
. c0ee sta $f0
. c0f0 lda $b4,x
. c0f2 sta $f1
. c0f4 pla
. c0f5 sta ($f0),y
. c0f7 rts

; ------------------------------------------------------------------------------
; Print one character at cursor position:
; AC: ASCII value; XR, YR: row, column
; Similar to $c0e7 but finishes with a cursor right.
; AC preserved.
; ------------------------------------------------------------------------------
. c0f8 pha
. c0f9 ldx $ca
. c0fb ldy $cb
. c0fd lda $a0,x
. c0ff sta $f0
. c101 lda $b4,x
. c103 sta $f1
. c105 pla
. c106 sta ($f0),y
. c108 jmp $c077
. c10b rts

; ------------------------------------------------------------------------------
; print string at cursor location
; :string_ptr - address of string
; set :cursor_row and :cursor_col before calling
; ------------------------------------------------------------------------------
. c10c ldy #$00
. c10e lda ($f4),y
. c110 beq $c11d
. c112 sty $fb
. c114 jsr $c0f8
. c117 ldy $fb
. c119 iny
. c11a jmp $c10e
. c11d rts

; ------------------------------------------------------------------------------
; print string at cursor location
; :string_ptr - address of string
; set :cursor_row and :cursor_col before calling
; ------------------------------------------------------------------------------
. c11e ldy #$00
. c120 lda ($f4),y
. c122 beq $c132
. c124 sty $fb
. c126 jsr $c0e7
. c129 jsr $c077
. c12c ldy $fb
. c12e iny
. c12f jmp $c120
. c132 jmp $c0a3
. c135 rts

; ------------------------------------------------------------------------------
; Clear screen; fills screen with nulls
; ------------------------------------------------------------------------------
. c136 lda $00
. c138 ldx #$fa
. c13a sta $0fff,x
. c13d sta $10f9,x
. c140 sta $11f3,x
. c143 sta $12ed,x
. c146 dex
. c147 bne $c13a
. c149 rts

; ------------------------------------------------------------------------------
; input string from keyboard
; :string_ptr - address of string to write
; :input_prompt - character for prompt
; :input_length - max characters
; set :cursor_row and :cursor_col before calling
; ------------------------------------------------------------------------------
. c14a lda $e0
. c14c jsr $c0f8
. c14f lda $20
. c151 jsr $c0f8
. c154 lda #$01
. c156 sta $cc
. c158 ldx #$00
. c15a lda $0e
. c15c beq $c15a

. c15e cmp #$08
. c160 bne $c174
. c162 cpx #$00
. c164 beq $c198
. c166 stx $fa
. c168 jsr $c0ab
. c16b ldx $fa
. c16d dex
. c16e sta $0200,x
. c171 jmp $c198

. c174 cmp #$0d
. c176 bne $c180
. c178 lda $20
. c17a jsr $c0e7
. c17d jmp $c19f

. c180 and #$60
. c182 bne $c187
. c184 jmp $c198
. c187 cpx $e1
. c189 beq $c198
. c18b stx $fa
. c18d lda $0e
. c18f sta $0200,x
. c192 jsr $c0f8
. c195 ldx $fa
. c197 inx

. c198 lda #$00
. c19a sta $0e
. c19c jmp $c15a

. c19f ldy #$00
. c1a1 lda $0200,y
. c1a4 beq $c1b1
. c1a6 sta ($f4),y
. c1a8 lda #$00
. c1aa sta $0200,y
. c1ad iny
. c1ae jmp $c1a1
. c1b1 sta ($f4),y

. c1b3 sta $0e
. c1b5 sta $cc
. c1b7 rts
