; John Conway's "Game of Life"
; cellular automaton.
; 650Vue version by Dr. Myles Skinner
;
; This 6502 version is really inefficient
; but it runs comfortably at 600kHz without
; delay loops so that may be an acceptable
; tradeoff.

> fffc 00 c0       ; reset vector

; --------------------------------------
; Title Screen
; --------------------------------------
> 1075 43 20 4f 20 4e 20 57 20 41 20 59 20 27 20 53
> 10dd 47 61 6d 65 20 6f 66
> 116a 4f 4f
> 119c 4f 4f 20 20 20 20 20 20 20 4f 4f
> 11ac 4f 4f 4f
> 11ce 4f 4f
> 11dd 4f 4f 20 20 20 20 20 4f 4f 4f 4f
> 1200 4f 4f 20 20 20 20 20 20 4f 4f 4f
> 120e 4f 4f 4f 4f 4f 20 20 4f 4f 20 20 4f 4f
> 1232 4f 4f 20 20 20 20 20 20 20 4f 4f
> 1241 4f 4f 20 20 20 20 4f 4f 4f 4f 4f 4f
> 1264 4f 4f 20 20 20 20 20 20 20 4f 4f
> 1273 4f 4f 20 20 20 20 4f 4f
> 1296 4f 4f 4f 4f 4f 4f 20 20 4f 4f 4f 4f
> 12a5 4f 4f 20 20 20 20 20 4f 4f 4f 4f
> 132b 67 20 63 30 30 30 20 6f
> 1333 72 20 70 72 65 73 73 20
> 133b 52 55 4e 20 74 6f 20 73 74 61 72 74

;
; Set up zero-page working memory
; $fc/$fd : constant 0x0032 for ADC/SBC
; $fe/$ff : screen RAM row pointer
;
. c000 LDA #$32    ; screen row (50 columns)
. c002 STA $fc     ; $0032 low byte for 16-bit
. c004 LDA #$00    ; addition in $d100
. c006 STA $fd     ; $0032 high byte

;
; Populate screen RAM with random cells
;
. c008 LDX #$fa    ; 250 bytes = 1/4 screen
. c00a JSR $d000   ; random cell subroutine
. c00d STA $0fff,x
. c010 JSR $d000
. c013 STA $10f9,x 
. c016 JSR $d000
. c019 STA $11f3,x
. c01c JSR $d000
. c01f STA $12ed,x
. c022 DEX 
. c023 BNE $c00a
;
; Initialize screen loop pointer
;
. c025 LDA #$00    
. c027 STA $fe     ; screen ram "home" low
. c029 LDA #$10
. c02b STA $ff     ; screen ram "home" high

; --------------------------------------
; Main loop; check for neighbours for 
; each (Y,X) coordinate pair. Normally
; (X,Y) would decribe a Cartesian 
; coordinate but we want the Y-register 
; for indirect, indexed lookups.
; X-register: screen row (vertical)
; Y-register: screen column (horizontal)
; --------------------------------------
. c02d LDX #$00    ; top row
. c02f LDY #$31    ; 50 columns (0 to 49)
. c031 JSR $d200   ; count neighbours for this cell
. c034 DEY
. c035 BPL $c031   ; advance on Y == #$ff
. c037 JSR $d100   ; advance pointer one row
. c03a INX
. c03b CPX #$14    ; 20 rows
. c03d BNE $c02f
. c03f NOP         ; TODO: remove
;
; Reset pointer to scratch memory
;
. c040 LDA #$00
. c042 STA $fe     ; scratch ram "home" low
. c044 LDA #$20
. c046 STA $ff     ; scratch ram "home" high
;
; copy working area to screen RAM
;
. c048 LDX #$00    ; top row
. c04a LDY #$31    ; 50 columns (0 to 49)
. c04c JSR $d600   ; update cell in screen RAM
. c04f DEY
. c050 BPL $c04c   ; advance on Y == #$ff
. c052 JSR $d100   ; advance pointer one row
. c055 INX
. c056 CPX #$14    ; 20 rows
. c058 BNE $c04a
. c05a JMP $c025   ; endless loop

; --------------------------------------
; Randomly select a single cell's status
; --------------------------------------
. d000 LDA $0f     ; random number
. d002 CMP #$40    ; probability of live cell
. d004 BCS $d009
. d006 LDA #$4f    ; O (live cell)
. d008 RTS
. d009 LDA #$20    ; space (empty cell)
. d00b RTS

; --------------------------------------
; 16-bit add $fc/$fd to $fe/$ff
; and store result in $fe/$ff
; --------------------------------------
. d100 CLC 
. d101 LDA $fe
. d103 ADC $fc
. d105 STA $fe
. d107 LDA $ff
. d109 ADC $fd
. d10b STA $ff
. d10d RTS

; --------------------------------------
; 16-bit add $fc/$fd to $fe/$ff
; and store result in $fa/$fb
; not very DRY but this is easy...
; --------------------------------------
. d110 CLC 
. d111 LDA $fe
. d113 ADC $fc
. d115 STA $fa
. d117 LDA $ff
. d119 ADC $fd
. d11b STA $fb
. d11d RTS

; --------------------------------------
; 16-bit subtract $fc/$fd from $fa/$fb
; and store result in $fa/$fb
; --------------------------------------
. d120 SEC
. d121 LDA $fa
. d123 SBC $fc
. d125 STA $fa
. d127 LDA $fb
. d129 SBC $fd
. d12b STA $fb
. d12d RTS

; --------------------------------------
; Count neighbours for one cell.
; Needs X and Y from main loop.
; --------------------------------------
; $fa/$fb - neighbour row pointer
; $f9     - neighbour count
; $f8     - stash Y-register
;
. d200 LDA #$00
. d202 STA $f9     ; start with 0 neighbours
. d204 STY $f8     ; save Y
. d206 LDA $fe     ; transfer screen row pointer
. d208 STA $fa     ; to neighbour row pointer
. d20a LDA $ff
. d20c STA $fb
;
; set pointer to row above unless X == 0
;
. d20e JSR $d120   ; subtract one row from pointer
. d211 CPX #$00    ; adjust for top row
. d213 BNE $d21d   ; if X == 0 then row 20
. d215 LDA #$b6    ; row 20 starts at $13b6
. d217 STA $fa
. d219 LDA #$13
. d21b STA $fb     
. d21d JSR $d300   ; count neighbours in row
;
; set pointer to row below unless X == 19
;
. d220 LDA $fe     ; reset neighbour row pointer
. d222 STA $fa
. d224 LDA $ff
. d226 STA $fb
. d228 JSR $d110   ; and again
. d22b CPX #$13    ; adjust for bottom row
. d22d BNE $d237   ; if X == 19 then row 0
. d22f LDA #$00    ; row 0 starts at $1000
. d231 STA $fa
. d233 LDA #$10
. d235 STA $fb
. d237 JSR $d300   ; count neighbours in row
. d23a LDA $fe     ; reset neighbour row pointer
. d23c STA $fa
. d23e LDA $ff
. d240 STA $fb
. d242 JSR $d400   ; count left and right
. d245 JSR $d500   ; write neighbour count to scratch
. d248 RTS

; --------------------------------------
; count neighbours in row
; --------------------------------------
. d300 LDY $f8     ; grab saved Y
;
; check cell above/below
;
. d302 LDA ($fa),y ; direct vertical adjacency
. d304 CMP #$20    ; empty space?
. d306 BEQ $d30a   ; empty: skip ahead
. d308 INC $f9     ; increment neighbour count
;
; check to the left
;
. d30a DEY         ; go to the left
. d30b BPL $d30f   ; negative is left underflow
. d30d LDY #$31    ; rightmost column
. d30f LDA ($fa),y ; diagonal left
. d311 CMP #$20    ; empty space?
. d313 BEQ $d317   ; empty: skip ahead
. d315 INC $f9     ; increment neighbour count
;
; check to the right
;
. d317 LDY $f8     ; grab saved Y
. d319 INY         ; go to the right
. d31a CPY #$32    ; right overflow?
. d31c BNE $d320
. d31e LDY #$00    ; leftmost column
. d320 LDA ($fa),y ; diagonal right
. d322 CMP #$20    ; empty space?
. d324 BEQ $d328   ; empty: skip ahead
. d326 INC $f9     ; increment neighbour count
. d328 LDY $f8     ; restore Y before returning
. d32a RTS

; --------------------------------------
; Check for left and right neighbours
; --------------------------------------
. d400 DEY         ; move left
. d401 BPL $d405   ; negative == left overflow
. d403 LDY #$31    ; rightmost column
. d405 LDA ($fa),y ; cell to the left
. d407 CMP #$20
. d409 BEQ $d40d
. d40b INC $f9
. d40d LDY $f8     ; reload Y
. d40f INY         ; move to the right
. d410 CPY #$32    ; right overflow?
. d412 BNE $d416
. d414 LDY #$00    ; leftmost column
. d416 LDA ($fa),y ; cell to the right
. d418 CMP #$20
. d41a BEQ $d41e
. d41c INC $f9
. d41e LDY $f8     ; reset Y
. d420 RTS

; --------------------------------------
; Store neighbour count in scratch area
; --------------------------------------
. d500 LDA $fe     ; restore screen row pointer
. d502 STA $fa
. d504 LDA $ff
. d506 STA $fb
. d508 LDY $f8     ; restore Y
. d50a LDA $fb     ; neighbour pointer MSB
. d50c EOR #$30    ; switch to scratch area
. d50e STA $fb
. d510 LDA $f9     ; neighbour count
. d512 STA ($fa),y ; store in scratch
. d514 RTS

; --------------------------------------
; update cell
; the Conway rules reduce to 3 conditions:
; 2 neighbours: no change
; 3 neighbours: always populate
; everything else dies
; --------------------------------------
. d600 LDA ($fe),y ; fetch number of neighbours
. d602 CMP #$02    ; 2 neighbours, do nothing
. d604 BEQ $d62b   ; exit routine
. d606 CMP #$03
. d608 BNE $d61b   ; make empty cell
. d60a LDA $ff
. d60c EOR #$30    ; shift to screen RAM
. d60e STA $ff
. d610 LDA #$4f
. d612 STA ($fe),y
. d614 LDA $ff
. d616 EOR #$30    ; shift back to scratch
. d618 STA $ff
. d61a RTS
. d61b LDA $ff
. d61d EOR #$30
. d61f STA $ff
. d621 LDA #$20
. d623 STA ($fe),y
. d625 LDA $ff
. d627 EOR #$30
. d629 STA $ff
. d62b RTS
