(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["about"],{"19d5":function(e,t,r){"use strict";var a=r("9674"),s=r.n(a);s.a},"3a01":function(e,t,r){},5249:function(e,t,r){"use strict";var a=r("3a01"),s=r.n(a);s.a},6316:function(e,t,r){"use strict";r.r(t);var a=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0)},s=[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"terminal-help-content"},[a("h1",[e._v("Using the Terminal")]),a("div",{staticClass:"row"},[a("div",{staticClass:"column-left"},[a("figure",[a("img",{attrs:{src:r("c025")}}),a("figcaption",[e._v("650Vue's "),a("em",[e._v("Vuepermon")]),e._v(" virtual terminal")])])]),a("div",{staticClass:"column-right"},[a("p",[e._v(" The main way of interacting with the 650Vue virtual machine is through the virtual terminal. The large, upper window displays the terminal's output, and the small, lower box is where you enter commands. There's no \"submit\" button; just enter a one-line command into the input box and press RETURN. The terminal will process your command and display the results in the output window. ")]),a("p",[e._v(" The terminal gives you access to a monitor that is similar to Jim Butterfield's "),a("a",{attrs:{href:"https://github.com/jblang/supermon64",target:"_blank"}},[e._v("Supermon")]),e._v(" for Commodore's 8-bit computers. Anyone who used Supermon back in the day should feel right at home with 650Vue's monitor—which, in the interest of terrible wordplay, we can call "),a("em",[e._v("Vuepermon")]),e._v(". With Vuepermon, you can examine and modify virtual RAM and the 6502's status registers. You can enter new instructions through the simple assembler and read through existing programs with the disassembler. You can load programs from the virtual disk and run them from the terminal. ")]),a("h2",[e._v("Vuepermon Command Reference")]),a("dl",[a("dt",[a("code",[e._v("d [<address>]")])]),a("dd",[e._v(" Example: "),a("code",[e._v("d c000")]),a("br"),e._v(" Disassemble 16 instructions beginning at <address>. After the first 16 lines are displayed, entering "),a("code",[e._v("d")]),e._v(" with no arguments will continue disassembling from where you left off. ")]),a("dt",[a("code",[e._v("g <address>")])]),a("dd",[e._v(" Example: "),a("code",[e._v("g c000")]),a("br"),e._v(" Begin executing code from "),a("code",[e._v("address")]),e._v(". 650Vue will continue execution until it encounters a "),a("code",[e._v("BRK")]),e._v(" instruction, an illegal opcode, or receives a Non-Maskable Interrupt telling it to stop. ")]),a("dt",[a("code",[e._v("l <filename>")])]),a("dd",[e._v(" Example: "),a("code",[e._v("l hello")]),a("br"),e._v(" Load "),a("code",[e._v("filename")]),e._v(" from the virtual disk. Do not enclose filename in quotes. ")]),a("dt",[a("code",[e._v("m [<start_address>] [<end_address>]")])]),a("dd",[e._v(" Example: "),a("code",[e._v("m bff0 c010")]),a("br"),e._v(" Display up to 128 bytes of memory beginning at "),a("code",[e._v("start_address")]),e._v(". Each line of the display will list a 16-bit hexadecimal address, then the hexadecimal values of the 8 bytes starting at that address, followed by the ASCII representation of those same 8 bytes. After the first screenful of data, entering "),a("code",[e._v("m")]),e._v(" with no arguments will continue displaying memory from where you left off. ")]),a("dt",[a("code",[e._v("p <address>")])]),a("dd",[e._v(" Example: "),a("code",[e._v("p c000")]),a("br"),e._v(" Set the Program Counter to "),a("code",[e._v("address")]),e._v(". Used when you want to start single-stepping from a specific instruction. ")]),a("dt",[a("code",[e._v("r")])]),a("dd",[e._v(" Display the 6502 registers. ")]),a("dt",[a("code",[e._v("z")])]),a("dd",[e._v(" Fill screen RAM with zeroes and force a screen refresh, effectively clearing the video display. ")]),a("dt",[a("code",[e._v("> <address> <byte> [<byte> <byte> ...]")])]),a("dd",[e._v(" Example: "),a("code",[e._v("> c010 48 65 6c 6c 6f 2c 20")]),a("br"),e._v(" Write a series of hexadecimal bytes to memory, beginning at "),a("code",[e._v("address")]),e._v(". You can enter as many bytes as will fit in a single line of input. ")]),a("dt",[a("code",[e._v("; <pc> <sr> <ac> <xr> <yr> <sp>")])]),a("dd",[e._v(" Example: "),a("code",[e._v("; c000 30 a0 00 00 fd")]),a("br"),e._v(" Set all the CPU registers. You must include all registers in order, from left to right: program counter, status register, accumulator, x-register, y-register, and stack pointer. ")]),a("dt",[a("code",[e._v(". <address> <opcode> [<operand>]")])]),a("dd",[e._v(" Example: "),a("code",[e._v(". c000 lda #$2a")]),a("br"),e._v(" Assemble one instruction at "),a("code",[e._v("address")]),e._v(". The assembler will determine the correct addressing mode from the syntax of "),a("code",[e._v("operand")]),e._v(". You must enter the operand precisely (see Addressing Modes below). When you enter a valid instruction, the terminal will prompt you to enter a new opcode at the next available address. ")])]),a("h2",[e._v("Addressing Modes")]),a("p",[e._v(" Vuepermon's assembler is very simple and not user-friendly. As of this writing, you can't use labels or macros and you have to enter instructions with the precise syntax the assembler expects. While I don't intend to teach 6502 assembly language here, I thought it would be helpful to lay out the address modes and their syntax for reference. ")]),a("table",[a("tr",[a("th",[e._v("Addressing Mode")]),a("th",[e._v("Example Syntax")]),a("th",[e._v("Comments")])]),a("tr",[a("td",[e._v("Absolute")]),a("td",[a("code",[e._v("jsr $ffd2")])])]),a("tr",[a("td",[e._v("Absolute,X")]),a("td",[a("code",[e._v("lda $c000,x")])])]),a("tr",[a("td",[e._v("Absolute,Y")]),a("td",[a("code",[e._v("sta $c000,y")])])]),a("tr",[a("td",[e._v("Accumulator")]),a("td",[a("code",[e._v("ror")])]),a("td",[e._v("Use "),a("code",[e._v("ror")]),e._v(" instead of "),a("code",[e._v("ror a")]),e._v(".")])]),a("tr",[a("td",[e._v("Immediate")]),a("td",[a("code",[e._v("lda #$2a")])])]),a("tr",[a("td",[e._v("Implied")]),a("td",[a("code",[e._v("dex")])])]),a("tr",[a("td",[e._v("Indexed, Indirect")]),a("td",[a("code",[e._v("lda ($20,x)")])])]),a("tr"),a("tr",[a("td",[e._v("Indirect")]),a("td",[a("code",[e._v("jmp ($c000)")])])]),a("tr",[a("td",[e._v("Indirect, Indexed")]),a("td",[a("code",[e._v("lda ($20),y")])])]),a("tr",[a("td",[e._v("Relative")]),a("td",[a("code",[e._v("beq $c010")])]),a("td",[e._v("Enter target address of branch.")])]),a("tr",[a("td",[e._v("Zero Page")]),a("td",[a("code",[e._v("lda $c0")])])]),a("tr",[a("td",[e._v("Zero Page,X")]),a("td",[a("code",[e._v("lda $fe,x")])])]),a("tr",[a("td",[e._v("Zero Page,Y")]),a("td",[a("code",[e._v("lda $fe,y")])])])]),a("p",[e._v(" The assembler expects lowercase operands but opcodes are not case-sensitive. The disassembler will display opcodes in ALL CAPS and operands in lowercase. ")])])])])}],o=(r("5249"),r("2877")),n={},i=Object(o["a"])(n,a,s,!1,null,"31a7b1d2",null);t["default"]=i.exports},"754b":function(e,t,r){"use strict";r.r(t);var a=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0)},s=[function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"about"},[r("div",{staticClass:"about-content"},[r("h1",[e._v("About 650Vue")]),r("p",[e._v(" 650Vue is a single-page application written in Vue.js that simulates the MOS 6502 microprocessor. The simulator includes register displays, status lights, an internal clock, a video display, file I/O (read-only in the public version), and a full-featured terminal with a machine-language monitor, assembler, and disassembler. 650Vue simulates the full official instruction set of the 6502 and even attempts to replicate some well-documented bugs in the original hardware. A Vuex store acts like a data bus and allows the virtual CPU to address a full 64 kilobytes of virtual RAM. The simulated internal clock, running at approximately 600kHz, can handle an IRQ interrupt service routine on each browser display repaint cycle. ")]),r("p",[e._v(" If you would like to learn more about how 650Vue is put together, you can "),r("a",{attrs:{href:"https://github.com/drskinner/650vue",target:"_blank"}},[e._v("browse the public repository")]),e._v(" on GitHub. The public version of 650Vue is hosted on GitHub at "),r("a",{attrs:{href:"https://drskinner.github.io/650vue/"}},[e._v("https://drskinner.github.io/650vue/")]),e._v(". ")]),r("h2",[e._v("Simulators vs. Emulators")]),r("p",[e._v(" 650Vue is more of a 6502 simulator than a 6502 emulator. A "),r("em",[e._v("simulator")]),e._v(" creates a software environment capable of executing arbitrary code; an "),r("em",[e._v("emulator")]),e._v(" attempts to mimic some real-world hardware as closely as possible. 650Vue does not emulate any actual computer hardware but employs a lot of tricks to simulate a working machine. There is no data bus and no address bus; the CPU registers and RAM all live in a Vuex store. File I/O is handled with an Axios call to local storage. The video \"display\" is a big textarea that mirrors the bytes stored in screen RAM. I've faked the clock oscillator (see below), but even so, 650Vue can run interrupt-driven 6502 machine-language programs as long as precise timing is not a requirement. Although 650Vue has no real-world analogue, it is a bit like a more user-friendly version of MOS Technology, Inc.'s "),r("a",{attrs:{href:"https://en.wikipedia.org/wiki/KIM-1"}},[e._v("KIM-1")]),e._v(" computer. ")]),r("h2",[e._v("Timing, Interrupts, and the Virtual Clock")]),r("p",[e._v(" 650Vue does not implement a precise clock. Instead, it will try to run 10,000 CPU cycles' worth of machine-language instructions on every browser repaint. The repaint typically occurs 60 times per second, so we can aspire to an effective clock rate of 600,000 CPU cycles per second, or 600kHz. However, the repaint rate tends to fluctuate, and a slow repaint or heavy garbage collection can put a serious dent in the browser's frame rate, causing the virtual CPU's effective clock speed to drop. 650Vue isn't really optimized for steady performance, but it can run programs at close to full speed if we're willing to tolerate small inaccuracies in the timing. ")]),r("p",[e._v(" 650Vue can handle interrupt requests. On each browser repaint frame, after the CPU has burned through 10,000-ish cycles, it will check bit 2 of the status register—the interrupt disable flag. If interrupts are enabled, the CPU will jump to the routine pointed to by the 6502's IRQ vector and will resume normal execution when it encounters an RTI (Return From Interrupt) instruction. You need to be careful, though, because interrupt-driven routines can eat a LOT of your computer's RAM and CPU. If your machine gets hot and your fan starts running excessively, the STOP button will generate an NMI (Non-Maskable Interrupt) and immediately halt execution. ")])])])}],o=(r("19d5"),r("2877")),n={},i=Object(o["a"])(n,a,s,!1,null,"6cb3bf07",null);t["default"]=i.exports},9674:function(e,t,r){},c025:function(e,t,r){e.exports=r.p+"img/terminal.9d9c2820.png"}}]);
//# sourceMappingURL=about.c9692e62.js.map